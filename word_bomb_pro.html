<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Bomb: Final Sound FX</title>
    <style>
        /* BASE STYLES */
        :root { --bg: #0f172a; --card: #1e293b; --primary: #38bdf8; --text: #f8fafc; --danger: #ef4444; --success: #4ade80; --warning: #fbbf24; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Segoe UI', sans-serif; background-color: var(--bg); color: var(--text); margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* UI HELPERS */
        .hidden { display: none !important; }
        .center { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .full-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: var(--bg); }

        /* LOBBY STYLES */
        .setup-card { background: var(--card); padding: 25px; border-radius: 20px; border: 1px solid #334155; width: 95%; max-width: 500px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); margin: auto; overflow-y: auto; max-height: 90vh; }
        .player-status-row { display: flex; justify-content: center; margin: 15px 0; gap: 8px; flex-wrap: wrap; }
        .p-status-box { flex: 1; min-width: 80px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; border: 2px solid #334155; transition: 0.3s; }
        .p-status-box.connected { border-color: var(--success); background: rgba(74, 222, 128, 0.1); }
        .p-badge { font-weight: bold; font-size: 0.75rem; display: block; margin-bottom: 5px; color: #94a3b8; }
        .p-conn-text { font-weight: 900; font-size: 0.9rem; color: var(--warning); }
        .connected .p-conn-text { color: var(--success); }
        
        .setting-row { margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; display: flex; align-items: center; justify-content: space-between; }
        .setting-label { font-size: 0.9rem; font-weight: bold; text-align: left; }
        .life-input { padding: 5px; border-radius: 5px; border: 1px solid var(--primary); background: #0f172a; color: white; width: 60px; text-align: center; font-weight: bold; }

        /* GAME HEADER */
        .game-header { padding: 15px; display: flex; justify-content: space-between; align-items: center; background: rgba(30, 41, 59, 0.5); border-bottom: 1px solid #334155; height: 60px; transition: height 0.3s; }
        .room-badge { background: #334155; padding: 5px 10px; border-radius: 5px; font-size: 0.8rem; font-weight: bold; }

        /* BOMB AREA */
        .gameplay-area { flex: 1; display: flex; flex-direction: column; width: 100%; position: relative; transition: all 0.3s; }
        .bomb-area { flex: 1; position: relative; transition: all 0.3s; }
        .bomb-circle { width: 200px; height: 200px; border-radius: 50%; background: radial-gradient(circle, #334155 0%, #0f172a 80%); border: 5px solid var(--primary); display: flex; align-items: center; justify-content: center; box-shadow: 0 0 40px rgba(56, 189, 248, 0.2); position: relative; z-index: 2; transition: all 0.3s; }
        .bomb-circle.explode { border-color: var(--danger); box-shadow: 0 0 50px var(--danger); animation: shake 0.5s; }
        .letter-display { font-size: 3.5rem; font-weight: 900; text-transform: uppercase; text-shadow: 0 0 15px var(--primary); transition: font-size 0.3s; }
        
        /* TIMER */
        .timer-info { margin-top: 20px; font-weight: bold; color: var(--warning); font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; transition: margin 0.3s; }
        .timer-bar-container { width: 80%; max-width: 300px; height: 10px; background: #334155; border-radius: 10px; margin-top: 5px; overflow: hidden; }
        .timer-fill { height: 100%; width: 100%; background: var(--success); transition: width 0.1s linear, background-color 0.3s; }

        /* INPUT AREA & HIGHLIGHT MIRROR */
        .input-container { padding: 20px; width: 100%; max-width: 500px; margin: 0 auto; position: relative; transition: padding 0.3s; }
        
        .input-wrapper { position: relative; height: 60px; width: 100%; }
        
        /* The real input is transparent but interactive */
        .word-input { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 0 20px; background: transparent; border: 2px solid #475569; border-radius: 15px; 
            color: transparent; caret-color: white; 
            font-size: 1.5rem; text-align: center; text-transform: uppercase; outline: none; transition: 0.3s; z-index: 2;
        }
        
        /* The mirror div shows colored text */
        .input-mirror {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 0 20px; background: var(--card); border-radius: 15px;
            color: white; font-size: 1.5rem; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            text-transform: uppercase; pointer-events: none; z-index: 1;
        }

        .word-input:focus { border-color: var(--primary); }
        .word-input.error { border-color: var(--danger); animation: shake 0.3s; }
        .highlight-match { color: var(--success); text-shadow: 0 0 10px var(--success); }

        .turn-indicator { text-align: center; margin-bottom: 10px; font-weight: bold; color: var(--warning); text-transform: uppercase; letter-spacing: 1px; font-size: 0.9rem; }

        /* PLAYERS BAR & TYPING BUBBLES */
        .players-bar { display: flex; padding: 10px; gap: 10px; background: #0f172a; border-top: 1px solid #334155; height: 130px; transition: height 0.3s; overflow-x: auto; }
        .player-card { flex: 1; min-width: 100px; background: var(--card); padding: 10px; border-radius: 12px; text-align: center; border: 2px solid transparent; opacity: 0.5; transition: 0.3s; display: flex; flex-direction: column; justify-content: center; position: relative; }
        .player-card.active { border-color: var(--primary); opacity: 1; background: rgba(56, 189, 248, 0.05); transform: translateY(-5px); }
        .player-card.dead { filter: grayscale(1); opacity: 0.3; border-color: var(--danger); }
        .p-name { font-weight: bold; font-size: 0.85rem; margin-bottom: 5px; color: #cbd5e1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .p-lives { font-size: 1rem; margin-bottom: 5px; }
        .p-score { font-size: 1.2rem; font-weight: 800; color: var(--primary); line-height: 1; }

        /* TYPING BUBBLE */
        .typing-bubble {
            position: absolute;
            top: -45px; left: 50%; transform: translateX(-50%);
            background: #ffffff; color: #0f172a;
            padding: 5px 12px; border-radius: 15px;
            font-size: 0.8rem; font-weight: 800; text-transform: uppercase;
            white-space: nowrap; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            opacity: 0; pointer-events: none; transition: opacity 0.2s, top 0.2s;
            z-index: 10;
        }
        .typing-bubble::after {
            content: ''; position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%);
            border-width: 6px; border-style: solid; border-color: #ffffff transparent transparent transparent;
        }
        .typing-bubble.visible { opacity: 1; top: -55px; }

        /* LOBBY ELEMENTS */
        .lobby-card { background: var(--card); padding: 30px; border-radius: 20px; border: 1px solid #334155; width: 90%; max-width: 400px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .title { font-size: 2.5rem; font-weight: 900; color: var(--primary); margin-bottom: 5px; text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { color: #94a3b8; margin-bottom: 30px; font-size: 0.9rem; }
        .input-code { width: 100%; padding: 15px; background: #0f172a; border: 2px solid #334155; border-radius: 10px; color: white; font-size: 1.5rem; text-align: center; margin-bottom: 15px; letter-spacing: 5px; text-transform: uppercase; font-weight: bold; }
        
        .btn { width: 100%; padding: 15px; border: none; border-radius: 10px; font-weight: bold; font-size: 1.1rem; cursor: pointer; transition: 0.2s; margin-bottom: 10px; }
        .btn-primary { background: var(--primary); color: #0f172a; }
        .btn-success { background: var(--success); color: #0f172a; }
        .btn:disabled { background: #334155; color: #94a3b8; cursor: not-allowed; }
        .btn:active { transform: scale(0.98); }

        /* OVERLAYS & COUNTDOWN */
        .countdown-overlay { font-size: 8rem; font-weight: 900; color: var(--warning); text-shadow: 0 0 30px rgba(251, 191, 36, 0.5); z-index: 50; animation: pulse 0.5s ease-in-out; }
        .game-over { background: rgba(15, 23, 42, 0.98); }
        .winner-text { font-size: 3rem; font-weight: 900; color: var(--warning); margin-bottom: 10px; }
        .retry-alert { font-size: 1.1rem; font-weight: bold; color: var(--warning); animation: pulse 1s infinite; display: none; margin-bottom: 5px;}
        
        /* CHAT SYSTEM STYLES */
        .chat-fab { position: fixed; bottom: 140px; right: 20px; width: 50px; height: 50px; background: var(--card); border: 2px solid var(--primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.5rem; cursor: pointer; box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 990; transition: transform 0.2s; }
        .chat-fab:active { transform: scale(0.9); }
        .chat-badge { position: absolute; top: -5px; right: -5px; background: var(--danger); color: white; font-size: 0.7rem; font-weight: bold; width: 22px; height: 22px; border-radius: 50%; display: flex; justify-content: center; align-items: center; }
        .chat-window { position: fixed; bottom: 200px; right: 20px; width: 300px; height: 400px; background: var(--card); border: 1px solid #334155; border-radius: 15px; display: flex; flex-direction: column; z-index: 1000; box-shadow: 0 10px 40px rgba(0,0,0,0.5); overflow: hidden; animation: slideUp 0.3s; }
        .chat-header { background: #0f172a; padding: 12px; font-weight: bold; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; align-items: center; }
        .close-chat { cursor: pointer; font-size: 1.2rem; padding: 0 5px; }
        .chat-messages { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; font-size: 0.9rem; }
        .chat-msg { max-width: 80%; padding: 8px 12px; border-radius: 12px; word-wrap: break-word; }
        .msg-me { align-self: flex-end; background: var(--primary); color: #0f172a; font-weight: 500; border-bottom-right-radius: 2px; }
        .msg-other { align-self: flex-start; background: #334155; color: white; border-bottom-left-radius: 2px; }
        .chat-sender-name { font-size: 0.65rem; opacity: 0.7; margin-bottom: 2px; display: block; }
        .chat-input-area { padding: 10px; border-top: 1px solid #334155; display: flex; gap: 5px; background: #0f172a; }
        .chat-input-area input { flex: 1; padding: 8px; border-radius: 5px; border: 1px solid #444; background: #1e293b; color: white; outline: none; }
        .chat-input-area button { background: var(--success); color: #0f172a; border: none; padding: 0 12px; border-radius: 5px; cursor: pointer; font-weight: bold; }

        /* --- MOBILE KEYBOARD FOCUS MODE --- */
        @media (max-width: 768px) {
            body.keyboard-active .game-header,
            body.keyboard-active .players-bar,
            body.keyboard-active .chat-fab { display: none !important; }
            body.keyboard-active .gameplay-area { justify-content: flex-start; padding-top: 10px; }
            body.keyboard-active .bomb-area { flex: 0 0 auto; margin-bottom: 10px; }
            body.keyboard-active .bomb-circle { width: 100px; height: 100px; border-width: 3px; }
            body.keyboard-active .letter-display { font-size: 2rem; }
            body.keyboard-active .timer-info { margin-top: 5px; font-size: 0.8rem; }
            body.keyboard-active .input-container { padding: 5px 20px; }
            body.keyboard-active .turn-indicator { margin-bottom: 5px; font-size: 0.8rem; }
            
            .bomb-circle { width: 160px; height: 160px; }
            .letter-display { font-size: 2.2rem; }
            .title { font-size: 2rem; }
            .p-status-box { padding: 8px; min-width: 70px; }
            .p-conn-text { font-size: 0.8rem; }
            .chat-window { width: 90%; right: 5%; bottom: 100px; height: 350px; }
            .chat-fab { bottom: 20px; right: 20px; }
        }

        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes pulse { 0% { transform: scale(0.95); opacity: 0.8; } 50% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(0.95); opacity: 0.8; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body>

    <audio id="sfx-tick" src="https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3"></audio>
    <audio id="sfx-explode" src="bomb.mp3"></audio> 
    <audio id="sfx-correct" src="https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3"></audio>
    <audio id="sfx-beep" src="https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3"></audio>
    <audio id="sfx-go" src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3"></audio>
    <audio id="sfx-critical" src="critis.mp3"></audio>

    <div id="lobby-screen" class="full-screen center">
        <div class="lobby-card">
            <div class="title">WORD BOMB</div>
            <div class="subtitle" style="color:#aaa; margin-bottom:20px;">Ultimate Battle</div>
            <input type="text" id="room-input" class="input-code" placeholder="CODE" maxlength="4">
            <button class="btn btn-primary" id="btn-create" onclick="createRoom()">CREATE ROOM (HOST)</button>
            <button class="btn btn-success" id="btn-join" onclick="joinRoom()">JOIN ROOM</button>
            <div id="lobby-status" class="status-text" style="color:#aaa; margin-top:10px;">Enter code to join or create new</div>
        </div>
    </div>

    <div id="game-screen" class="hidden" style="height: 100vh; display: flex; flex-direction: column;">
        
        <div class="game-header">
            <div class="room-badge">ROOM: <span id="display-room-code" style="color:var(--warning)">----</span></div>
            <div id="role-display" style="font-size:0.8rem; font-weight:bold; color:#aaa;">PLAYER</div>
        </div>

        <div id="setup-area" class="center" style="flex:1;">
            <div class="setup-card">
                <h2 style="color:var(--primary); margin-bottom:20px;">GAME LOBBY</h2>
                
                <div style="background:rgba(255,255,255,0.1); padding:10px; border-radius:10px; margin-bottom:15px; font-size:0.85rem; color:#cbd5e1; text-align:left; border: 1px solid #475569;">
                    <div style="color:var(--warning); font-weight:bold; margin-bottom:5px;">üìã Cara Bermain:</div>
                    1. Bom menampilkan huruf acak (Contoh: "ING").<br>
                    2. Ketik kata bahasa Inggris yang mengandung huruf tersebut.<br>
                    3. Jika gagal, nyawa hilang & soal dilempar ke lawan.<br>
                    4. Jika semua gagal, soal baru muncul.
                </div>

                <div class="player-status-row">
                    <div class="p-status-box connected" id="p1-conn-box">
                        <span class="p-badge">PLAYER 1 (HOST)</span>
                        <div class="p-conn-text">CONNECTED</div>
                    </div>
                    <div class="p-status-box" id="p2-conn-box">
                        <span class="p-badge">PLAYER 2</span>
                        <div class="p-conn-text" id="p2-conn-text">WAITING...</div>
                    </div>
                    <div class="p-status-box" id="p3-conn-box" style="display:none;">
                        <span class="p-badge">PLAYER 3</span>
                        <div class="p-conn-text" id="p3-conn-text">WAITING...</div>
                    </div>
                </div>

                <div class="setting-row">
                    <label class="setting-label">Total Players (1-3):</label>
                    <input type="number" id="player-count-input" class="life-input" value="2" min="1" max="3" onchange="updatePlayerCount()" disabled>
                </div>
                <div class="setting-row">
                    <label class="setting-label">Start Lives:</label>
                    <input type="number" id="lives-input" class="life-input" value="3" min="1" max="10" onchange="updateSettings()" disabled>
                </div>
                <div class="setting-row">
                    <label class="setting-label">Seconds per Turn:</label>
                    <input type="number" id="maxtime-input" class="life-input" value="10" min="3" max="60" onchange="updateSettings()" disabled>
                </div>

                <div id="host-actions" class="hidden">
                    <button id="btn-start-game" class="btn btn-success" onclick="initiateGame()" disabled>START GAME</button>
                    <p style="font-size:0.8rem; color:#888;" id="host-hint-msg">Waiting for players...</p>
                </div>
                <div id="client-msg" class="hidden">
                    <p style="font-size:1rem; color:var(--warning); font-weight:bold;">Waiting for Host to Start...</p>
                </div>
            </div>
        </div>

        <div id="gameplay-area" class="gameplay-area hidden">
            <div class="bomb-area center">
                <div class="bomb-circle" id="bomb-circle">
                    <span id="prompt-display" class="letter-display">---</span>
                </div>
                <div id="countdown-display" class="full-screen center hidden" style="background:rgba(15,23,42,0.8);">
                    <div id="countdown-number" class="countdown-overlay">3</div>
                </div>
                <div class="timer-info">TIME LIMIT: <span id="time-limit-display">10</span>s</div>
                <div class="timer-bar-container">
                    <div id="timer-bar" class="timer-fill"></div>
                </div>
            </div>

            <div class="input-container">
                <div id="retry-alert" class="retry-alert">TRYING SAME WORD...</div>
                <div id="turn-indicator" class="turn-indicator">GAME STARTING...</div>
                
                <div class="input-wrapper">
                    <div id="input-mirror" class="input-mirror">TYPE HERE...</div>
                    <input type="text" id="word-input" class="word-input" autocomplete="off" disabled>
                </div>
            </div>

            <div class="players-bar">
                <div id="p1-card" class="player-card">
                    <div class="typing-bubble" id="p1-typing">typing...</div>
                    <div class="p-name">P1 (HOST)</div>
                    <div class="p-lives" id="p1-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                    <div class="p-score" id="p1-score">0</div>
                </div>
                <div id="p2-card" class="player-card">
                    <div class="typing-bubble" id="p2-typing">typing...</div>
                    <div class="p-name">PLAYER 2</div>
                    <div class="p-lives" id="p2-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                    <div class="p-score" id="p2-score">0</div>
                </div>
                <div id="p3-card" class="player-card" style="display:none;">
                    <div class="typing-bubble" id="p3-typing">typing...</div>
                    <div class="p-name">PLAYER 3</div>
                    <div class="p-lives" id="p3-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                    <div class="p-score" id="p3-score">0</div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="full-screen center hidden game-over">
        <div class="winner-text" id="winner-display">PLAYER 1 WINS!</div>
        <div class="subtitle" style="margin-bottom: 30px;">Game Over</div>
        <div style="display:flex; gap:20px; margin-bottom:30px; text-align:center; flex-wrap:wrap; justify-content:center;">
            <div>
                <div style="font-size:0.8rem; color:#aaa;">PLAYER 1</div>
                <div id="end-p1-score" style="font-size:2rem; font-weight:bold; color:var(--primary);">0</div>
            </div>
            <div id="end-p2-container">
                <div style="font-size:0.8rem; color:#aaa;">PLAYER 2</div>
                <div id="end-p2-score" style="font-size:2rem; font-weight:bold; color:var(--danger);">0</div>
            </div>
            <div id="end-p3-container" style="display:none;">
                <div style="font-size:0.8rem; color:#aaa;">PLAYER 3</div>
                <div id="end-p3-score" style="font-size:2rem; font-weight:bold; color:var(--warning);">0</div>
            </div>
        </div>
        <button class="btn btn-primary" id="btn-play-again" style="max-width:200px;" onclick="resetGameByHost()">MAIN LAGI</button>
        <p id="waiting-host-msg" class="status-text hidden">Waiting for Host...</p>
    </div>

    <div id="chat-fab" class="chat-fab hidden" onclick="toggleChat()">
        üí¨ <span id="chat-badge" class="chat-badge hidden">0</span>
    </div>

    <div id="chat-window" class="chat-window hidden">
        <div class="chat-header">
            <span>ROOM CHAT</span>
            <span class="close-chat" onclick="toggleChat()">√ó</span>
        </div>
        <div id="chat-messages" class="chat-messages"></div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="Say something...">
            <button onclick="sendChatMessage()">‚û§</button>
        </div>
    </div>

<script src="word_bomb_pro.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getDatabase, ref, set, onValue, update, get, remove, push } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

   const firebaseConfig = {
  apiKey: "AIzaSyAgYCaaoGMzZWVT2dRov7ALUnnMhHoqXmE",
  authDomain: "english-check-db.firebaseapp.com",
  databaseURL: "https://english-check-db-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "english-check-db",
  storageBucket: "english-check-db.firebasestorage.app",
  messagingSenderId: "136352630898",
  appId: "1:136352630898:web:dcaa103fa848ca38de9aeb"
};

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // --- GAME STATE ---
    let myRole = 0; 
    let currentRoom = "";
    let localTimer;
    let usedWords = [];
    let currentTurnDuration = 10; 
    let lastActionProcessed = ""; 
    let lastHostTimerAction = ""; // New tracker for Host Timer
    let currentPrompt = ""; // Local prompt for highlighting
    let currentGameState = null; // Cache state for optimization
    
    // --- LOBBY LOGIC ---
    window.createRoom = function() {
        const btn = document.getElementById('btn-create');
        const status = document.getElementById('lobby-status');
        const maxPlayers = parseInt(document.getElementById('player-count-input').value);
        
        btn.disabled = true; status.innerText = "Creating...";

        const code = Math.floor(1000 + Math.random() * 9000).toString();
        
        set(ref(db, 'rooms/' + code), {
            status: 'waiting', 
            config: { maxLives: 3, maxTime: 10, maxPlayers: maxPlayers }, 
            turn: 1,
            isRetry: false,
            prompt: "---",
            scores: { 1: 0, 2: 0, 3: 0 },
            lives: { 1: 3, 2: 3, 3: 3 },
            players: { p1: 'connected' }, 
            promptFailCount: 0, 
            lastAction: 'created',
            usedWords: [],
            msg: '',
            typing: {} 
        }).then(() => { enterGame(code, 1); })
          .catch((e) => { alert(e.message); btn.disabled = false; });
    };

    window.joinRoom = function() {
        const code = document.getElementById('room-input').value.trim();
        const btn = document.getElementById('btn-join');
        if (code.length !== 4) { alert("Enter 4 digit code!"); return; }
        
        btn.disabled = true; document.getElementById('lobby-status').innerText = "Joining...";

        const roomRef = ref(db, 'rooms/' + code);
        get(roomRef).then((snap) => {
            if (snap.exists()) {
                const data = snap.val();
                let role = 0;
                
                if (!data.players || !data.players.p2) role = 2;
                else if (data.config.maxPlayers >= 3 && !data.players.p3) role = 3;
                
                if (role === 0) {
                    alert("Room Penuh!");
                    btn.disabled = false;
                    return;
                }

                set(ref(db, 'rooms/' + code + '/players/p' + role), 'connected').then(() => {
                    enterGame(code, role);
                });
            } else {
                alert("Room not found!");
                btn.disabled = false;
            }
        });
    };

    function enterGame(code, role) {
        currentRoom = code;
        myRole = role;
        
        document.getElementById('lobby-screen').classList.add('hidden');
        document.getElementById('game-screen').classList.remove('hidden');
        document.getElementById('display-room-code').innerText = code;
        document.getElementById('role-display').innerText = "YOU ARE PLAYER " + role + (role===1 ? " (HOST)" : "");

        if (role === 1) {
            document.getElementById('host-actions').classList.remove('hidden');
            document.getElementById('lives-input').disabled = false;
            document.getElementById('maxtime-input').disabled = false;
            document.getElementById('player-count-input').disabled = false;
        } else {
            document.getElementById('client-msg').classList.remove('hidden');
            document.getElementById('btn-play-again').classList.add('hidden');
            document.getElementById('waiting-host-msg').classList.remove('hidden');
        }

        document.getElementById('chat-fab').classList.remove('hidden');
        listenToRoom();
        listenToChat();
        
        const wordInput = document.getElementById('word-input');
        wordInput.addEventListener('focus', () => document.body.classList.add('keyboard-active'));
        wordInput.addEventListener('blur', () => document.body.classList.remove('keyboard-active'));
        wordInput.addEventListener('input', handleInputEvent);
        
        listenToTyping();
    }

    // --- REAL-TIME TYPING ---
    function handleInputEvent(e) {
        const text = e.target.value.toUpperCase();
        updateInputMirror(text);
        update(ref(db, 'rooms/' + currentRoom + '/typing/' + myRole), {
            text: text,
            timestamp: Date.now()
        });
    }

    function updateInputMirror(text) {
        const mirror = document.getElementById('input-mirror');
        const prompt = currentPrompt;
        
        if (!prompt || prompt === "---") {
            mirror.innerText = text || "TYPE HERE...";
            return;
        }

        const idx = text.indexOf(prompt);
        if (idx !== -1) {
            const before = text.substring(0, idx);
            const match = text.substring(idx, idx + prompt.length);
            const after = text.substring(idx + prompt.length);
            mirror.innerHTML = `${before}<span class="highlight-match">${match}</span>${after}`;
        } else {
            mirror.innerText = text || "TYPE HERE...";
        }
    }

    function listenToTyping() {
        onValue(ref(db, 'rooms/' + currentRoom + '/typing'), (snap) => {
            const data = snap.val();
            if (!data) return;

            for (let i = 1; i <= 3; i++) {
                if (i === myRole) continue; 
                
                const bubble = document.getElementById(`p${i}-typing`);
                const typingData = data[i];
                
                if (typingData && typingData.text && (Date.now() - typingData.timestamp < 3000)) {
                    bubble.innerText = typingData.text;
                    bubble.classList.add('visible');
                } else {
                    bubble.classList.remove('visible');
                }
            }
        });
    }

    // --- SETTINGS ---
    window.updateSettings = function() {
        if(myRole !== 1) return;
        const lives = parseInt(document.getElementById('lives-input').value);
        const time = parseInt(document.getElementById('maxtime-input').value);
        if(lives > 0 && time >= 3) {
            update(ref(db, 'rooms/' + currentRoom + '/config'), { maxLives: lives, maxTime: time });
        }
    }
    
    window.updatePlayerCount = function() {
        if(myRole !== 1) return;
        const count = parseInt(document.getElementById('player-count-input').value);
        if(count >= 1 && count <= 3) {
            update(ref(db, 'rooms/' + currentRoom + '/config'), { maxPlayers: count });
        }
    }

    // --- START SEQUENCE ---
    window.initiateGame = function() {
        if(myRole !== 1) return;
        const maxLives = parseInt(document.getElementById('lives-input').value);
        const maxTime = parseInt(document.getElementById('maxtime-input').value);
        
        update(ref(db, 'rooms/' + currentRoom), {
            lives: { 1: maxLives, 2: maxLives, 3: maxLives },
            scores: { 1: 0, 2: 0, 3: 0 },
            usedWords: [],
            status: 'countdown',
            promptFailCount: 0,
            turnDuration: maxTime,
            msg: '3'
        });
        startCountdownSequence();
    }

    function startCountdownSequence() {
        let count = 3;
        const interval = setInterval(() => {
            count--;
            if(count > 0) {
                update(ref(db, 'rooms/' + currentRoom), { msg: count.toString() });
            } else if (count === 0) {
                update(ref(db, 'rooms/' + currentRoom), { msg: 'GO!' });
            } else {
                clearInterval(interval);
                startTurn(1, false); 
                update(ref(db, 'rooms/' + currentRoom), { status: 'playing', msg: '' });
            }
        }, 1000);
    }

    // --- MAIN LISTENER ---
    function listenToRoom() {
        const roomRef = ref(db, 'rooms/' + currentRoom);
        onValue(roomRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) return;

            // Cache data locally for immediate Host logic
            currentGameState = data;

            usedWords = data.usedWords || [];
            currentTurnDuration = data.config.maxTime || 10;
            currentPrompt = data.prompt; 

            // Sync Settings UI
            if(data.config) {
                document.getElementById('lives-input').value = data.config.maxLives;
                document.getElementById('maxtime-input').value = data.config.maxTime;
                document.getElementById('player-count-input').value = data.config.maxPlayers;
                document.getElementById('time-limit-display').innerText = data.config.maxTime;
                
                if (data.config.maxPlayers >= 3) {
                    document.getElementById('p3-conn-box').style.display = 'block';
                    document.getElementById('p3-card').style.display = 'flex';
                    document.getElementById('end-p3-container').style.display = 'block';
                } else {
                    document.getElementById('p3-conn-box').style.display = 'none';
                    document.getElementById('p3-card').style.display = 'none';
                    document.getElementById('end-p3-container').style.display = 'none';
                }
            }

            // Sync Lobby Players
            if(data.players) {
                const btnStart = document.getElementById('btn-start-game');
                let count = 1;
                
                if (data.players.p2 === 'connected') {
                    document.getElementById('p2-conn-box').classList.add('connected');
                    document.getElementById('p2-conn-text').innerText = "CONNECTED";
                    count++;
                }
                
                if (data.players.p3 === 'connected') {
                    document.getElementById('p3-conn-box').classList.add('connected');
                    document.getElementById('p3-conn-text').innerText = "CONNECTED";
                    count++;
                }
                
                if (myRole === 1) {
                    if (data.config && count >= data.config.maxPlayers) {
                        btnStart.disabled = false;
                        document.getElementById('host-hint-msg').innerText = "Ready to start!";
                    } else {
                        btnStart.disabled = true;
                        document.getElementById('host-hint-msg').innerText = "Waiting for players...";
                    }
                }
            }

            // State Management
            const setupArea = document.getElementById('setup-area');
            const gameplayArea = document.getElementById('gameplay-area');
            const countdownDisplay = document.getElementById('countdown-display');
            const cdNum = document.getElementById('countdown-number');

            if (data.status === 'waiting') {
                setupArea.classList.remove('hidden');
                gameplayArea.classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('game-screen').classList.remove('hidden');
                
            } else if (data.status === 'countdown') {
                setupArea.classList.add('hidden');
                gameplayArea.classList.remove('hidden');
                countdownDisplay.classList.remove('hidden');
                cdNum.innerText = data.msg;
                if(data.msg === 'GO!') document.getElementById('sfx-go').play().catch(()=>{});
                else document.getElementById('sfx-beep').play().catch(()=>{});

            } else if (data.status === 'playing') {
                setupArea.classList.add('hidden');
                gameplayArea.classList.remove('hidden');
                countdownDisplay.classList.add('hidden');
                updateGameplayUI(data);
            }
        });
    }

    function updateGameplayUI(data) {
        document.getElementById('p1-score').innerText = data.scores[1];
        document.getElementById('p2-score').innerText = data.scores[2];
        document.getElementById('p3-score').innerText = data.scores[3] || 0;
        
        document.getElementById('p1-lives').innerText = "‚ù§Ô∏è".repeat(data.lives[1]);
        document.getElementById('p2-lives').innerText = "‚ù§Ô∏è".repeat(data.lives[2]);
        document.getElementById('p3-lives').innerText = "‚ù§Ô∏è".repeat(data.lives[3] || 0);
        
        document.getElementById('prompt-display').innerText = data.prompt;
        
        document.getElementById('p1-card').classList.toggle('active', data.turn === 1);
        document.getElementById('p2-card').classList.toggle('active', data.turn === 2);
        document.getElementById('p3-card').classList.toggle('active', data.turn === 3);
        
        if (data.lives[1] <= 0) document.getElementById('p1-card').classList.add('dead');
        if (data.lives[2] <= 0) document.getElementById('p2-card').classList.add('dead');
        if (data.lives[3] <= 0) document.getElementById('p3-card').classList.add('dead');

        // Check if I am dead
        if (data.lives[myRole] <= 0 && data.status === 'playing') {
             const input = document.getElementById('word-input');
             input.disabled = true;
             input.value = "";
             document.getElementById('input-mirror').innerText = "YOU ARE OUT!";
             document.getElementById('turn-indicator').innerText = "SPECTATING...";
             document.getElementById('turn-indicator').style.color = "var(--danger)";
             return;
        }

        const retryAlert = document.getElementById('retry-alert');
        if (data.promptFailCount > 0) {
            retryAlert.style.display = 'block';
            retryAlert.innerText = `SAME QUESTION!`;
        } else {
            retryAlert.style.display = 'none';
        }

        const input = document.getElementById('word-input');
        const indicator = document.getElementById('turn-indicator');
        
        // Game Over Logic
        let aliveCount = 0;
        let lastAlive = 0;
        for(let i=1; i<=data.config.maxPlayers; i++) {
            if(data.lives[i] > 0) { aliveCount++; lastAlive = i; }
        }
        
        if (data.config.maxPlayers === 1) {
            if (aliveCount === 0) {
                handleGameOver("GAME OVER", data.scores);
                return;
            }
        } else {
            if (aliveCount <= 1) {
                handleGameOver("PLAYER " + lastAlive + " WINS!", data.scores);
                return;
            }
        }

        if (data.turn === myRole) {
            input.disabled = false;
            if(document.activeElement !== input) input.focus();
            indicator.innerText = "YOUR TURN!";
            indicator.style.color = "var(--success)";
        } else {
            input.disabled = true;
            input.value = "";
            document.getElementById('input-mirror').innerText = "";
            indicator.innerText = `OPPONENT'S TURN...`;
            indicator.style.color = "var(--warning)";
        }

        if (data.lastAction.includes('explode')) {
            document.getElementById('sfx-explode').play().catch(()=>{});
            document.getElementById('bomb-circle').classList.add('explode');
            setTimeout(() => document.getElementById('bomb-circle').classList.remove('explode'), 500);
        } else if (data.lastAction.includes('correct')) {
            document.getElementById('sfx-correct').play().catch(()=>{});
        }
        
        // --- KEY FIX FOR TIMER RESET ---
        // Only restart visual timer if action CHANGED and is a 'start_turn'
        if (data.lastAction !== lastActionProcessed && data.lastAction.includes('start_turn')) {
            startVisualTimer(data.config.maxTime); 
            lastActionProcessed = data.lastAction;
        }
        
        // Only start host timer if action CHANGED (Prevents restart on every typing update)
        if (myRole === 1 && data.status === 'playing') {
             if (data.lastAction !== lastHostTimerAction) {
                 startHostTimer(data.turn, data.isRetry, data.config.maxTime);
                 lastHostTimerAction = data.lastAction;
             }
        }
    }

    // --- HOST LOGIC ---
    let hostTimerInterval;
    
    function startTurn(nextPlayer, isRetry) {
        if (myRole !== 1) return;

        let newPrompt = null; 
        
        // OPTIMIZATION: Use cached state
        const data = currentGameState; 
        
        if (!isRetry) {
            let validPrompt = false;
            while (!validPrompt) {
                const word = dictionary[Math.floor(Math.random() * dictionary.length)];
                if(word.length < 3) continue; 
                const len = Math.random() < 0.5 ? 2 : 3;
                const start = Math.floor(Math.random() * (word.length - len));
                newPrompt = word.substring(start, start + len).toUpperCase();
                if (!newPrompt.includes("-")) validPrompt = true;
            }
            if(data) data.promptFailCount = 0;
        } else {
            newPrompt = data.prompt;
        }

        update(ref(db, 'rooms/' + currentRoom), {
            turn: nextPlayer,
            prompt: newPrompt,
            promptFailCount: (data ? data.promptFailCount : 0),
            isRetry: isRetry,
            lastAction: 'start_turn_' + Date.now()
        });
    }

    function startHostTimer(playerTurn, isRetry, durationSec) {
        clearInterval(hostTimerInterval);
        let timeLeft = durationSec * 10; 
        
        hostTimerInterval = setInterval(() => {
            timeLeft--;
            if (timeLeft <= 0) {
                clearInterval(hostTimerInterval);
                handleTimeUp(playerTurn);
            }
        }, 100);
    }

    function handleTimeUp(player) {
        if (!currentGameState || currentGameState.status !== 'playing') return;

        let lives = currentGameState.lives;
        lives[player]--; 
        
        let failCount = (currentGameState.promptFailCount || 0) + 1;
        let nextPlayer = (player % currentGameState.config.maxPlayers) + 1;
        
        let attempts = 0;
        while(lives[nextPlayer] <= 0 && attempts < 3) {
            nextPlayer = (nextPlayer % currentGameState.config.maxPlayers) + 1;
            attempts++;
        }

        let aliveCount = 0;
        for(let i=1; i<=currentGameState.config.maxPlayers; i++) { 
            if(lives[i] > 0) aliveCount++; 
        }
        
        let isRetry = true;
        if (failCount >= aliveCount) {
            isRetry = false; 
        } else if (currentGameState.config.maxPlayers === 1) {
            isRetry = false; 
        }

        // Update DB
        update(ref(db, 'rooms/' + currentRoom), {
            lives: lives,
            promptFailCount: failCount,
            lastAction: 'explode_' + Date.now()
        });

        // FAST SWITCH (200ms delay)
        if ((currentGameState.config.maxPlayers > 1 && aliveCount > 1) || (currentGameState.config.maxPlayers === 1 && lives[1] > 0)) {
            setTimeout(() => startTurn(nextPlayer, isRetry), 200); 
        }
    }

    // --- CLIENT INPUT ---
    document.getElementById('word-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitWord();
    });

    function submitWord() {
        const input = document.getElementById('word-input');
        const word = input.value.trim().toLowerCase();
        
        if (!word) return;
        const prompt = currentPrompt.toLowerCase();
        
        if (usedWords.includes(word)) {
            input.value = "";
            document.getElementById('input-mirror').innerText = "SUDAH DIPAKAI!";
            input.classList.add('error');
            setTimeout(() => { 
                input.classList.remove('error'); 
                document.getElementById('input-mirror').innerText = "TYPE HERE..."; 
            }, 800);
            return;
        }

        if (!word.includes(prompt) || !dictionary.includes(word)) {
            input.classList.add('error');
            setTimeout(() => input.classList.remove('error'), 300);
            return;
        }

        if (myRole === 1) {
            processValidMove(1, word);
        } else {
            update(ref(db, 'rooms/' + currentRoom + '/input'), {
                player: myRole, 
                word: word,
                timestamp: Date.now()
            });
        }
        input.value = "";
        document.getElementById('input-mirror').innerText = "";
    }

    let lastProcessedTime = 0;
    setInterval(() => {
        if (myRole === 1 && !window.hostListening) {
            window.hostListening = true;
            onValue(ref(db, 'rooms/' + currentRoom + '/input'), (snap) => {
                const data = snap.val();
                if (data && data.timestamp > lastProcessedTime) {
                    lastProcessedTime = data.timestamp;
                    processValidMove(data.player, data.word);
                }
            });
        }
    }, 1000);

    function processValidMove(player, word) {
        if (!currentGameState) return;

        let used = currentGameState.usedWords || [];
        if (used.includes(word)) return; 
        
        let scores = currentGameState.scores;
        scores[player]++;
        used.push(word);
        
        let nextPlayer = (player % currentGameState.config.maxPlayers) + 1;
        let attempts = 0;
        while(currentGameState.lives[nextPlayer] <= 0 && attempts < 3) {
            nextPlayer = (nextPlayer % currentGameState.config.maxPlayers) + 1;
            attempts++;
        }

        update(ref(db, 'rooms/' + currentRoom), {
            scores: scores,
            usedWords: used,
            lastAction: 'correct_' + Date.now()
        });

        clearInterval(hostTimerInterval);
        startTurn(nextPlayer, false); 
    }

    // --- VISUAL TIMER ---
    function startVisualTimer(durationSec) {
        const bar = document.getElementById('timer-bar');
        bar.style.width = "100%";
        bar.style.backgroundColor = "var(--success)";
        let pct = 100;
        let criticalPlayed = false;

        if (window.visualInterval) clearInterval(window.visualInterval);

        const step = 100 / (durationSec * 10);

        window.visualInterval = setInterval(() => {
            pct -= step; 
            bar.style.width = pct + "%";
            
            let remainingSeconds = (pct / 100) * durationSec;

            if (remainingSeconds <= 3 && remainingSeconds > 0 && !criticalPlayed) {
                document.getElementById('sfx-critical').play().catch(()=>{});
                criticalPlayed = true;
            }

            if (pct < 40) bar.style.backgroundColor = "var(--warning)";
            if (pct < 15) {
                bar.style.backgroundColor = "var(--danger)";
                document.getElementById('sfx-tick').play().catch(()=>{});
            }
            if (pct <= 0) clearInterval(window.visualInterval);
        }, 100);
    }

    function handleGameOver(winner, scores) {
        clearInterval(window.visualInterval);
        document.getElementById('game-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.remove('hidden');
        document.getElementById('winner-display').innerText = winner;
        document.getElementById('end-p1-score').innerText = scores[1];
        document.getElementById('end-p2-score').innerText = scores[2];
        document.getElementById('end-p3-score').innerText = scores[3] || 0;
        
        if (myRole !== 1) {
            document.getElementById('btn-play-again').classList.add('hidden');
            document.getElementById('waiting-host-msg').classList.remove('hidden');
        }
    }

    window.resetGameByHost = function() {
        if (myRole !== 1) return;
        
        get(ref(db, 'rooms/' + currentRoom + '/config')).then((snap) => {
            const config = snap.val() || { maxLives: 3, maxTime: 10, maxPlayers: 2 };
            
            update(ref(db, 'rooms/' + currentRoom), {
                status: 'waiting',
                scores: { 1: 0, 2: 0, 3: 0 },
                lives: { 1: config.maxLives, 2: config.maxLives, 3: config.maxLives },
                prompt: '---',
                usedWords: [],
                promptFailCount: 0,
                lastAction: 'reset_' + Date.now()
            });
        });
    }

    // --- CHAT SYSTEM LOGIC ---
    let isChatOpen = false;
    let unreadCount = 0;

    window.toggleChat = function() {
        const win = document.getElementById('chat-window');
        const badge = document.getElementById('chat-badge');
        
        if (isChatOpen) {
            win.classList.add('hidden');
            isChatOpen = false;
        } else {
            win.classList.remove('hidden');
            isChatOpen = true;
            unreadCount = 0;
            badge.classList.add('hidden');
            scrollToBottom();
        }
    }

    window.sendChatMessage = function() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if(!text) return;

        const senderName = myRole === 1 ? "Host" : "Player " + myRole;
        
        push(ref(db, 'rooms/' + currentRoom + '/chat'), {
            sender: senderName,
            text: text,
            role: myRole,
            timestamp: Date.now()
        });
        
        input.value = "";
    }

    function listenToChat() {
        const chatRef = ref(db, 'rooms/' + currentRoom + '/chat');
        onValue(chatRef, (snapshot) => {
            const container = document.getElementById('chat-messages');
            container.innerHTML = "";
            
            if (snapshot.exists()) {
                const msgs = snapshot.val();
                
                Object.keys(msgs).forEach(key => {
                    const m = msgs[key];
                    const isMe = m.role === myRole;
                    const div = document.createElement('div');
                    div.className = `chat-msg ${isMe ? 'msg-me' : 'msg-other'}`;
                    div.innerHTML = `<span class="chat-sender-name">${isMe ? 'You' : m.sender}</span>${m.text}`;
                    container.appendChild(div);
                });

                scrollToBottom();

                if (!isChatOpen) {
                    unreadCount++;
                    const badge = document.getElementById('chat-badge');
                    badge.innerText = unreadCount;
                    badge.classList.remove('hidden');
                }
            }
        });
    }

    function scrollToBottom() {
        const container = document.getElementById('chat-messages');
        container.scrollTop = container.scrollHeight;
    }

    document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if(e.key === 'Enter') window.sendChatMessage();
    });

</script>
</body>
</html>