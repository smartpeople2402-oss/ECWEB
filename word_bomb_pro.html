<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Bomb: Chat Edition</title>
    <style>
        /* BASE STYLES */
        :root { --bg: #0f172a; --card: #1e293b; --primary: #38bdf8; --text: #f8fafc; --danger: #ef4444; --success: #4ade80; --warning: #fbbf24; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Segoe UI', sans-serif; background-color: var(--bg); color: var(--text); margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* UI HELPERS */
        .hidden { display: none !important; }
        .center { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .full-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: var(--bg); }

        /* LOBBY STYLES */
        .setup-card { background: var(--card); padding: 25px; border-radius: 20px; border: 1px solid #334155; width: 90%; max-width: 450px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); margin: auto; }
        .player-status-row { display: flex; justify-content: space-between; margin: 20px 0; gap: 10px; }
        .p-status-box { flex: 1; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px; border: 2px solid #334155; }
        .p-status-box.connected { border-color: var(--success); background: rgba(74, 222, 128, 0.1); }
        .p-badge { font-weight: bold; font-size: 0.9rem; display: block; margin-bottom: 5px; color: #94a3b8; }
        .p-conn-text { font-weight: 900; font-size: 1.1rem; color: var(--warning); }
        .connected .p-conn-text { color: var(--success); }
        
        .setting-row { margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; display: flex; align-items: center; justify-content: space-between; }
        .setting-label { font-size: 0.9rem; font-weight: bold; text-align: left; }
        .life-input { padding: 5px; border-radius: 5px; border: 1px solid var(--primary); background: #0f172a; color: white; width: 60px; text-align: center; font-weight: bold; }

        /* GAME HEADER */
        .game-header { padding: 15px; display: flex; justify-content: space-between; align-items: center; background: rgba(30, 41, 59, 0.5); border-bottom: 1px solid #334155; height: 60px; }
        .room-badge { background: #334155; padding: 5px 10px; border-radius: 5px; font-size: 0.8rem; font-weight: bold; }

        /* BOMB AREA */
        .gameplay-area { flex: 1; display: flex; flex-direction: column; width: 100%; position: relative; }
        .bomb-area { flex: 1; position: relative; }
        .bomb-circle { width: 200px; height: 200px; border-radius: 50%; background: radial-gradient(circle, #334155 0%, #0f172a 80%); border: 5px solid var(--primary); display: flex; align-items: center; justify-content: center; box-shadow: 0 0 40px rgba(56, 189, 248, 0.2); position: relative; z-index: 2; transition: border-color 0.3s; }
        .bomb-circle.explode { border-color: var(--danger); box-shadow: 0 0 50px var(--danger); animation: shake 0.5s; }
        .letter-display { font-size: 3.5rem; font-weight: 900; text-transform: uppercase; text-shadow: 0 0 15px var(--primary); }
        
        /* TIMER */
        .timer-info { margin-top: 20px; font-weight: bold; color: var(--warning); font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }
        .timer-bar-container { width: 80%; max-width: 300px; height: 10px; background: #334155; border-radius: 10px; margin-top: 5px; overflow: hidden; }
        .timer-fill { height: 100%; width: 100%; background: var(--success); transition: width 0.1s linear, background-color 0.3s; }

        /* INPUT AREA */
        .input-container { padding: 20px; width: 100%; max-width: 500px; margin: 0 auto; position: relative; }
        .word-input { width: 100%; padding: 20px; background: var(--card); border: 2px solid #475569; border-radius: 15px; color: white; font-size: 1.5rem; text-align: center; text-transform: uppercase; outline: none; transition: 0.3s; }
        .word-input:focus { border-color: var(--primary); box-shadow: 0 0 20px rgba(56, 189, 248, 0.1); }
        .word-input.error { border-color: var(--danger); animation: shake 0.3s; color: var(--danger); }
        .word-input::placeholder { color: #64748b; font-size: 1.2rem; }
        .turn-indicator { text-align: center; margin-bottom: 10px; font-weight: bold; color: var(--warning); text-transform: uppercase; letter-spacing: 1px; font-size: 0.9rem; }

        /* PLAYERS BAR */
        .players-bar { display: flex; padding: 10px; gap: 10px; background: #0f172a; border-top: 1px solid #334155; height: 120px; }
        .player-card { flex: 1; background: var(--card); padding: 10px; border-radius: 12px; text-align: center; border: 2px solid transparent; opacity: 0.5; transition: 0.3s; display: flex; flex-direction: column; justify-content: center; }
        .player-card.active { border-color: var(--primary); opacity: 1; background: rgba(56, 189, 248, 0.05); transform: translateY(-5px); }
        .p-name { font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; color: #cbd5e1; }
        .p-lives { font-size: 1.2rem; margin-bottom: 5px; }
        .p-score { font-size: 1.5rem; font-weight: 800; color: var(--primary); line-height: 1; }

        /* LOBBY ELEMENTS */
        .lobby-card { background: var(--card); padding: 30px; border-radius: 20px; border: 1px solid #334155; width: 90%; max-width: 400px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .title { font-size: 2.5rem; font-weight: 900; color: var(--primary); margin-bottom: 5px; text-transform: uppercase; letter-spacing: 2px; }
        .input-code { width: 100%; padding: 15px; background: #0f172a; border: 2px solid #334155; border-radius: 10px; color: white; font-size: 1.5rem; text-align: center; margin-bottom: 15px; letter-spacing: 5px; text-transform: uppercase; font-weight: bold; }
        
        .btn { width: 100%; padding: 15px; border: none; border-radius: 10px; font-weight: bold; font-size: 1.1rem; cursor: pointer; transition: 0.2s; margin-bottom: 10px; }
        .btn-primary { background: var(--primary); color: #0f172a; }
        .btn-success { background: var(--success); color: #0f172a; }
        .btn:disabled { background: #334155; color: #94a3b8; cursor: not-allowed; }

        /* OVERLAYS & COUNTDOWN */
        .countdown-overlay { font-size: 8rem; font-weight: 900; color: var(--warning); text-shadow: 0 0 30px rgba(251, 191, 36, 0.5); z-index: 50; animation: pulse 0.5s ease-in-out; }
        .game-over { background: rgba(15, 23, 42, 0.98); }
        .winner-text { font-size: 3rem; font-weight: 900; color: var(--warning); margin-bottom: 10px; }
        .retry-alert { font-size: 1.1rem; font-weight: bold; color: var(--warning); animation: pulse 1s infinite; display: none; margin-bottom: 5px;}
        
        /* CHAT SYSTEM STYLES */
        .chat-fab { position: fixed; bottom: 130px; right: 20px; width: 60px; height: 60px; background: var(--card); border: 2px solid var(--primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.8rem; cursor: pointer; box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 990; transition: transform 0.2s; }
        .chat-fab:active { transform: scale(0.9); }
        .chat-badge { position: absolute; top: -5px; right: -5px; background: var(--danger); color: white; font-size: 0.7rem; font-weight: bold; width: 22px; height: 22px; border-radius: 50%; display: flex; justify-content: center; align-items: center; }
        
        .chat-window { position: fixed; bottom: 200px; right: 20px; width: 300px; height: 400px; background: var(--card); border: 1px solid #334155; border-radius: 15px; display: flex; flex-direction: column; z-index: 1000; box-shadow: 0 10px 40px rgba(0,0,0,0.5); overflow: hidden; animation: slideUp 0.3s; }
        .chat-header { background: #0f172a; padding: 12px; font-weight: bold; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; align-items: center; }
        .close-chat { cursor: pointer; font-size: 1.2rem; padding: 0 5px; }
        .chat-messages { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; font-size: 0.9rem; }
        .chat-msg { max-width: 80%; padding: 8px 12px; border-radius: 12px; word-wrap: break-word; }
        .msg-me { align-self: flex-end; background: var(--primary); color: #0f172a; font-weight: 500; border-bottom-right-radius: 2px; }
        .msg-other { align-self: flex-start; background: #334155; color: white; border-bottom-left-radius: 2px; }
        .chat-sender-name { font-size: 0.65rem; opacity: 0.7; margin-bottom: 2px; display: block; }
        
        .chat-input-area { padding: 10px; border-top: 1px solid #334155; display: flex; gap: 5px; background: #0f172a; }
        .chat-input-area input { flex: 1; padding: 8px; border-radius: 5px; border: 1px solid #444; background: #1e293b; color: white; outline: none; }
        .chat-input-area button { background: var(--success); color: #0f172a; border: none; padding: 0 12px; border-radius: 5px; cursor: pointer; font-weight: bold; }

        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes pulse { 0% { transform: scale(0.95); opacity: 0.8; } 50% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(0.95); opacity: 0.8; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        @media (max-width: 400px) {
            .bomb-circle { width: 160px; height: 160px; }
            .letter-display { font-size: 2.2rem; }
            .title { font-size: 2rem; }
            .p-status-box { padding: 10px; }
            .p-conn-text { font-size: 0.9rem; }
            .chat-window { width: 90%; right: 5%; bottom: 100px; height: 350px; }
            .chat-fab { bottom: 20px; right: 20px; }
        }
    </style>
</head>
<body>

    <audio id="sfx-tick" src="https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3"></audio>
    <audio id="sfx-explode" src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3"></audio>
    <audio id="sfx-correct" src="https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3"></audio>
    <audio id="sfx-beep" src="https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3"></audio>
    <audio id="sfx-go" src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3"></audio>

    <div id="lobby-screen" class="full-screen center">
        <div class="lobby-card">
            <div class="title">WORD BOMB</div>
            <div class="subtitle" style="color:#aaa; margin-bottom:20px;">Persistent Battle</div>
            <input type="text" id="room-input" class="input-code" placeholder="CODE" maxlength="4">
            <button class="btn btn-primary" id="btn-create" onclick="createRoom()">CREATE ROOM (HOST)</button>
            <button class="btn btn-success" id="btn-join" onclick="joinRoom()">JOIN ROOM</button>
            <div id="lobby-status" class="status-text" style="color:#aaa; margin-top:10px;">Enter code to join or create new</div>
        </div>
    </div>

    <div id="game-screen" class="hidden" style="height: 100vh; display: flex; flex-direction: column;">
        
        <div class="game-header">
            <div class="room-badge">ROOM: <span id="display-room-code" style="color:var(--warning)">----</span></div>
            <div id="role-display" style="font-size:0.8rem; font-weight:bold; color:#aaa;">PLAYER</div>
        </div>

        <div id="setup-area" class="center" style="flex:1;">
            <div class="setup-card">
                <h2 style="color:var(--primary); margin-bottom:20px;">GAME LOBBY</h2>
                <div class="player-status-row">
                    <div class="p-status-box connected">
                        <span class="p-badge">HOST (YOU)</span>
                        <div class="p-conn-text">CONNECTED</div>
                    </div>
                    <div class="p-status-box" id="p2-conn-box">
                        <span class="p-badge">PLAYER 2</span>
                        <div class="p-conn-text" id="p2-conn-text">WAITING...</div>
                    </div>
                </div>
                <div class="setting-row">
                    <label class="setting-label">Start Lives:</label>
                    <input type="number" id="lives-input" class="life-input" value="3" min="1" max="10" onchange="updateSettings()" disabled>
                </div>
                <div class="setting-row">
                    <label class="setting-label">Seconds per Turn:</label>
                    <input type="number" id="maxtime-input" class="life-input" value="10" min="3" max="60" onchange="updateSettings()" disabled>
                </div>
                <div id="host-actions" class="hidden">
                    <button id="btn-start-game" class="btn btn-success" onclick="initiateGame()" disabled>START GAME</button>
                    <p style="font-size:0.8rem; color:#888;">Wait for Player 2 to connect...</p>
                </div>
                <div id="client-msg" class="hidden">
                    <p style="font-size:1rem; color:var(--warning); font-weight:bold;">Waiting for Host to Start...</p>
                </div>
            </div>
        </div>

        <div id="gameplay-area" class="gameplay-area hidden">
            <div class="bomb-area center">
                <div class="bomb-circle" id="bomb-circle">
                    <span id="prompt-display" class="letter-display">---</span>
                </div>
                <div id="countdown-display" class="full-screen center hidden" style="background:rgba(15,23,42,0.8);">
                    <div id="countdown-number" class="countdown-overlay">3</div>
                </div>
                <div class="timer-info">TIME LIMIT: <span id="time-limit-display">10</span>s</div>
                <div class="timer-bar-container">
                    <div id="timer-bar" class="timer-fill"></div>
                </div>
            </div>

            <div class="input-container">
                <div id="retry-alert" class="retry-alert">TRYING SAME WORD...</div>
                <div id="turn-indicator" class="turn-indicator">GAME STARTING...</div>
                <input type="text" id="word-input" class="word-input" placeholder="TYPE HERE..." autocomplete="off" disabled>
            </div>

            <div class="players-bar">
                <div id="p1-card" class="player-card">
                    <div class="p-name">PLAYER 1 (HOST)</div>
                    <div class="p-lives" id="p1-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                    <div class="p-score" id="p1-score">0</div>
                </div>
                <div id="p2-card" class="player-card">
                    <div class="p-name">PLAYER 2</div>
                    <div class="p-lives" id="p2-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                    <div class="p-score" id="p2-score">0</div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="full-screen center hidden game-over">
        <div class="winner-text" id="winner-display">PLAYER 1 WINS!</div>
        <div class="subtitle" style="margin-bottom: 30px;">Game Over</div>
        <div style="display:flex; gap:20px; margin-bottom:30px; text-align:center;">
            <div>
                <div style="font-size:0.8rem; color:#aaa;">PLAYER 1</div>
                <div id="end-p1-score" style="font-size:2rem; font-weight:bold; color:var(--primary);">0</div>
            </div>
            <div>
                <div style="font-size:0.8rem; color:#aaa;">PLAYER 2</div>
                <div id="end-p2-score" style="font-size:2rem; font-weight:bold; color:var(--danger);">0</div>
            </div>
        </div>
        <button class="btn btn-primary" id="btn-play-again" style="max-width:200px;" onclick="resetGameByHost()">MAIN LAGI</button>
        <p id="waiting-host-msg" class="status-text hidden">Waiting for Host...</p>
    </div>

    <div id="chat-fab" class="chat-fab hidden" onclick="toggleChat()">
        üí¨ <span id="chat-badge" class="chat-badge hidden">0</span>
    </div>

    <div id="chat-window" class="chat-window hidden">
        <div class="chat-header">
            <span>ROOM CHAT</span>
            <span class="close-chat" onclick="toggleChat()">√ó</span>
        </div>
        <div id="chat-messages" class="chat-messages">
            </div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="Say something...">
            <button onclick="sendChatMessage()">‚û§</button>
        </div>
    </div>

<script src="word_bomb_pro.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getDatabase, ref, set, onValue, update, get, remove, push } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

   const firebaseConfig = {
  apiKey: "AIzaSyAgYCaaoGMzZWVT2dRov7ALUnnMhHoqXmE",
  authDomain: "english-check-db.firebaseapp.com",
  databaseURL: "https://english-check-db-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "english-check-db",
  storageBucket: "english-check-db.firebasestorage.app",
  messagingSenderId: "136352630898",
  appId: "1:136352630898:web:dcaa103fa848ca38de9aeb"
};

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

   
    // --- GAME STATE ---
    let myRole = 0; 
    let currentRoom = "";
    let localTimer;
    let usedWords = [];
    let currentTurnDuration = 10; 
    
    // --- LOBBY LOGIC ---
    window.createRoom = function() {
        const btn = document.getElementById('btn-create');
        const status = document.getElementById('lobby-status');
        btn.disabled = true; status.innerText = "Creating...";

        const code = Math.floor(1000 + Math.random() * 9000).toString();
        
        set(ref(db, 'rooms/' + code), {
            status: 'waiting', 
            config: { maxLives: 3, maxTime: 10 }, 
            turn: 1,
            isRetry: false,
            prompt: "---",
            scores: { 1: 0, 2: 0 },
            lives: { 1: 3, 2: 3 },
            players: { p1: 'connected', p2: 'waiting' },
            lastAction: 'created',
            usedWords: [],
            msg: ''
        }).then(() => { enterGame(code, 1); })
          .catch((e) => { alert(e.message); btn.disabled = false; });
    };

    window.joinRoom = function() {
        const code = document.getElementById('room-input').value.trim();
        const btn = document.getElementById('btn-join');
        if (code.length !== 4) { alert("Enter 4 digit code!"); return; }
        
        btn.disabled = true; document.getElementById('lobby-status').innerText = "Joining...";

        const roomRef = ref(db, 'rooms/' + code);
        get(roomRef).then((snap) => {
            if (snap.exists()) {
                update(roomRef, { 'players/p2': 'connected' });
                enterGame(code, 2);
            } else {
                alert("Room not found!");
                btn.disabled = false;
            }
        });
    };

    function enterGame(code, role) {
        currentRoom = code;
        myRole = role;
        
        document.getElementById('lobby-screen').classList.add('hidden');
        document.getElementById('game-screen').classList.remove('hidden');
        document.getElementById('display-room-code').innerText = code;
        document.getElementById('role-display').innerText = role === 1 ? "YOU ARE HOST (P1)" : "YOU ARE PLAYER 2";

        if (role === 1) {
            document.getElementById('host-actions').classList.remove('hidden');
            document.getElementById('lives-input').disabled = false;
            document.getElementById('maxtime-input').disabled = false;
        } else {
            document.getElementById('client-msg').classList.remove('hidden');
            document.getElementById('btn-play-again').classList.add('hidden');
            document.getElementById('waiting-host-msg').classList.remove('hidden');
        }

        document.getElementById('chat-fab').classList.remove('hidden');
        listenToRoom();
        listenToChat();
    }

    // --- SETTINGS ---
    window.updateSettings = function() {
        if(myRole !== 1) return;
        const lives = parseInt(document.getElementById('lives-input').value);
        const time = parseInt(document.getElementById('maxtime-input').value);
        if(lives > 0 && time >= 3) {
            update(ref(db, 'rooms/' + currentRoom + '/config'), { maxLives: lives, maxTime: time });
        }
    }

    // --- START SEQUENCE ---
    window.initiateGame = function() {
        if(myRole !== 1) return;
        const maxLives = parseInt(document.getElementById('lives-input').value);
        const maxTime = parseInt(document.getElementById('maxtime-input').value);
        
        update(ref(db, 'rooms/' + currentRoom), {
            lives: { 1: maxLives, 2: maxLives },
            scores: { 1: 0, 2: 0 },
            usedWords: [],
            status: 'countdown',
            isRetry: false,
            turnDuration: maxTime,
            msg: '3'
        });
        startCountdownSequence();
    }

    function startCountdownSequence() {
        let count = 3;
        const interval = setInterval(() => {
            count--;
            if(count > 0) {
                update(ref(db, 'rooms/' + currentRoom), { msg: count.toString() });
            } else if (count === 0) {
                update(ref(db, 'rooms/' + currentRoom), { msg: 'GO!' });
            } else {
                clearInterval(interval);
                startTurn(1, false); 
                update(ref(db, 'rooms/' + currentRoom), { status: 'playing', msg: '' });
            }
        }, 1000);
    }

    // --- MAIN LISTENER ---
    function listenToRoom() {
        const roomRef = ref(db, 'rooms/' + currentRoom);
        onValue(roomRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) return;

            usedWords = data.usedWords || [];
            currentTurnDuration = data.config.maxTime || 10;

            // Sync Settings UI
            if(data.config) {
                document.getElementById('lives-input').value = data.config.maxLives;
                document.getElementById('maxtime-input').value = data.config.maxTime;
                document.getElementById('time-limit-display').innerText = data.config.maxTime;
            }

            // Sync Lobby Players
            if(data.players) {
                const p2Box = document.getElementById('p2-conn-box');
                const p2Text = document.getElementById('p2-conn-text');
                const startBtn = document.getElementById('btn-start-game');

                if(data.players.p2 === 'connected') {
                    p2Box.classList.add('connected');
                    p2Text.innerText = "CONNECTED";
                    startBtn.disabled = false; 
                } else {
                    p2Box.classList.remove('connected');
                    p2Text.innerText = "WAITING...";
                    startBtn.disabled = true;
                }
            }

            // State Management
            const setupArea = document.getElementById('setup-area');
            const gameplayArea = document.getElementById('gameplay-area');
            const countdownDisplay = document.getElementById('countdown-display');
            const cdNum = document.getElementById('countdown-number');

            if (data.status === 'waiting') {
                setupArea.classList.remove('hidden');
                gameplayArea.classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('game-screen').classList.remove('hidden');
                
            } else if (data.status === 'countdown') {
                setupArea.classList.add('hidden');
                gameplayArea.classList.remove('hidden');
                countdownDisplay.classList.remove('hidden');
                cdNum.innerText = data.msg;
                if(data.msg === 'GO!') document.getElementById('sfx-go').play().catch(()=>{});
                else document.getElementById('sfx-beep').play().catch(()=>{});

            } else if (data.status === 'playing') {
                setupArea.classList.add('hidden');
                gameplayArea.classList.remove('hidden');
                countdownDisplay.classList.add('hidden');
                updateGameplayUI(data);
            }
        });
    }

    function updateGameplayUI(data) {
        document.getElementById('p1-score').innerText = data.scores[1];
        document.getElementById('p2-score').innerText = data.scores[2];
        document.getElementById('p1-lives').innerText = "‚ù§Ô∏è".repeat(data.lives[1]);
        document.getElementById('p2-lives').innerText = "‚ù§Ô∏è".repeat(data.lives[2]);
        document.getElementById('prompt-display').innerText = data.prompt;
        
        document.getElementById('p1-card').classList.toggle('active', data.turn === 1);
        document.getElementById('p2-card').classList.toggle('active', data.turn === 2);

        const retryAlert = document.getElementById('retry-alert');
        if (data.isRetry) {
            retryAlert.style.display = 'block';
            retryAlert.innerText = `SAME QUESTION!`;
        } else {
            retryAlert.style.display = 'none';
        }

        const input = document.getElementById('word-input');
        const indicator = document.getElementById('turn-indicator');
        
        if (data.lives[1] <= 0 || data.lives[2] <= 0) {
            handleGameOver(data.lives[1] > 0 ? "PLAYER 1" : "PLAYER 2", data.scores);
            return;
        }

        if (data.turn === myRole) {
            input.disabled = false;
            input.focus();
            indicator.innerText = "YOUR TURN!";
            indicator.style.color = "var(--success)";
        } else {
            input.disabled = true;
            input.value = "";
            indicator.innerText = `OPPONENT'S TURN...`;
            indicator.style.color = "var(--warning)";
        }

        if (data.lastAction.includes('explode')) {
            document.getElementById('sfx-explode').play().catch(()=>{});
            document.getElementById('bomb-circle').classList.add('explode');
            setTimeout(() => document.getElementById('bomb-circle').classList.remove('explode'), 500);
        } else if (data.lastAction.includes('correct')) {
            document.getElementById('sfx-correct').play().catch(()=>{});
        }
        
        if (data.lastAction.includes('start_turn')) {
            startVisualTimer(data.config.maxTime); 
        }
        
        if (myRole === 1 && !localTimer && data.status === 'playing') {
            startHostTimer(data.turn, data.isRetry, data.config.maxTime);
        }
    }

    // --- HOST LOGIC ---
    let hostTimerInterval;
    
    function startTurn(nextPlayer, isRetry) {
        if (myRole !== 1) return;

        let newPrompt = null; 
        get(ref(db, 'rooms/' + currentRoom)).then((snap) => {
            const data = snap.val();
            
            if (!isRetry) {
                const word = dictionary[Math.floor(Math.random() * dictionary.length)];
                const len = Math.random() < 0.5 ? 2 : 3;
                const start = Math.floor(Math.random() * (word.length - len));
                newPrompt = word.substring(start, start + len).toUpperCase();
            } else {
                newPrompt = data.prompt;
            }

            update(ref(db, 'rooms/' + currentRoom), {
                turn: nextPlayer,
                prompt: newPrompt,
                isRetry: isRetry,
                lastAction: 'start_turn_' + Date.now()
            });
        });
    }

    function startHostTimer(playerTurn, isRetry, durationSec) {
        clearInterval(hostTimerInterval);
        let timeLeft = durationSec * 10; 
        
        hostTimerInterval = setInterval(() => {
            timeLeft--;
            if (timeLeft <= 0) {
                clearInterval(hostTimerInterval);
                handleTimeUp(playerTurn, isRetry);
            }
        }, 100);
    }

    function handleTimeUp(player, isRetry) {
        get(ref(db, 'rooms/' + currentRoom)).then((snap) => {
            const data = snap.val();
            if(data.status !== 'playing') return;

            let lives = data.lives;
            lives[player]--; 
            
            update(ref(db, 'rooms/' + currentRoom), {
                lives: lives,
                lastAction: 'explode_' + Date.now()
            });

            if (lives[1] > 0 && lives[2] > 0) {
                if (!isRetry) {
                    // First failure -> Same question to other player
                    setTimeout(() => startTurn(player === 1 ? 2 : 1, true), 1000);
                } else {
                    // Second failure (Retry failed) -> New question to other player
                    setTimeout(() => startTurn(player === 1 ? 2 : 1, false), 1000);
                }
            }
        });
    }

    // --- CLIENT INPUT ---
    document.getElementById('word-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitWord();
    });

    function submitWord() {
        const input = document.getElementById('word-input');
        const word = input.value.trim().toLowerCase();
        
        if (!word) return;
        const prompt = document.getElementById('prompt-display').innerText.toLowerCase();
        
        if (usedWords.includes(word)) {
            input.value = "";
            input.placeholder = "SUDAH DIPAKAI!";
            input.classList.add('error');
            setTimeout(() => { input.classList.remove('error'); input.placeholder = "TYPE HERE..."; }, 800);
            return;
        }

        if (!word.includes(prompt) || !dictionary.includes(word)) {
            input.classList.add('error');
            setTimeout(() => input.classList.remove('error'), 300);
            return;
        }

        if (myRole === 1) {
            processValidMove(1, word);
        } else {
            update(ref(db, 'rooms/' + currentRoom + '/input'), {
                player: 2,
                word: word,
                timestamp: Date.now()
            });
        }
        input.value = "";
    }

    let lastProcessedTime = 0;
    setInterval(() => {
        if (myRole === 1 && !window.hostListening) {
            window.hostListening = true;
            onValue(ref(db, 'rooms/' + currentRoom + '/input'), (snap) => {
                const data = snap.val();
                if (data && data.timestamp > lastProcessedTime) {
                    lastProcessedTime = data.timestamp;
                    processValidMove(2, data.word);
                }
            });
        }
    }, 1000);

    function processValidMove(player, word) {
        get(ref(db, 'rooms/' + currentRoom)).then((snap) => {
            const data = snap.val();
            let used = data.usedWords || [];
            if (used.includes(word)) return; 
            
            let scores = data.scores;
            scores[player]++;
            used.push(word);

            update(ref(db, 'rooms/' + currentRoom), {
                scores: scores,
                usedWords: used,
                lastAction: 'correct_' + Date.now()
            });

            clearInterval(hostTimerInterval);
            startTurn(player === 1 ? 2 : 1, false);
        });
    }

    function startVisualTimer(durationSec) {
        const bar = document.getElementById('timer-bar');
        bar.style.width = "100%";
        bar.style.backgroundColor = "var(--success)";
        let pct = 100;
        
        if (window.visualInterval) clearInterval(window.visualInterval);

        const step = 100 / (durationSec * 10);

        window.visualInterval = setInterval(() => {
            pct -= step; 
            bar.style.width = pct + "%";
            if (pct < 40) bar.style.backgroundColor = "var(--warning)";
            if (pct < 15) {
                bar.style.backgroundColor = "var(--danger)";
                document.getElementById('sfx-tick').play().catch(()=>{});
            }
            if (pct <= 0) clearInterval(window.visualInterval);
        }, 100);
    }

    function handleGameOver(winner, scores) {
        clearInterval(window.visualInterval);
        document.getElementById('game-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.remove('hidden');
        document.getElementById('winner-display').innerText = winner + " WINS!";
        document.getElementById('end-p1-score').innerText = scores[1];
        document.getElementById('end-p2-score').innerText = scores[2];
        
        if (myRole === 2) {
            document.getElementById('btn-play-again').classList.add('hidden');
            document.getElementById('waiting-host-msg').classList.remove('hidden');
        }
    }

    window.resetGameByHost = function() {
        if (myRole !== 1) return;
        get(ref(db, 'rooms/' + currentRoom + '/config')).then((snap) => {
            const config = snap.val() || { maxLives: 3, maxTime: 10 };
            update(ref(db, 'rooms/' + currentRoom), {
                status: 'waiting',
                scores: { 1: 0, 2: 0 },
                lives: { 1: config.maxLives, 2: config.maxLives },
                prompt: '---',
                usedWords: [],
                isRetry: false,
                lastAction: 'reset_' + Date.now()
            });
        });
    }

    // --- CHAT SYSTEM LOGIC ---
    let isChatOpen = false;
    let unreadCount = 0;

    window.toggleChat = function() {
        const win = document.getElementById('chat-window');
        const badge = document.getElementById('chat-badge');
        
        if (isChatOpen) {
            win.classList.add('hidden');
            isChatOpen = false;
        } else {
            win.classList.remove('hidden');
            isChatOpen = true;
            unreadCount = 0;
            badge.classList.add('hidden');
            scrollToBottom();
        }
    }

    window.sendChatMessage = function() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if(!text) return;

        const senderName = myRole === 1 ? "Player 1" : "Player 2";
        
        push(ref(db, 'rooms/' + currentRoom + '/chat'), {
            sender: senderName,
            text: text,
            role: myRole,
            timestamp: Date.now()
        });
        
        input.value = "";
    }

    function listenToChat() {
        const chatRef = ref(db, 'rooms/' + currentRoom + '/chat');
        onValue(chatRef, (snapshot) => {
            const container = document.getElementById('chat-messages');
            container.innerHTML = "";
            
            if (snapshot.exists()) {
                const msgs = snapshot.val();
                let lastKey = "";
                
                Object.keys(msgs).forEach(key => {
                    const m = msgs[key];
                    const isMe = m.role === myRole;
                    const div = document.createElement('div');
                    div.className = `chat-msg ${isMe ? 'msg-me' : 'msg-other'}`;
                    div.innerHTML = `<span class="chat-sender-name">${isMe ? 'You' : m.sender}</span>${m.text}`;
                    container.appendChild(div);
                    lastKey = key;
                });

                scrollToBottom();

                // Handle Badge
                if (!isChatOpen) {
                    // Simple logic: if new data came in, increment badge
                    // Ideally check timestamps, but this is a quick game
                    unreadCount++;
                    const badge = document.getElementById('chat-badge');
                    badge.innerText = unreadCount;
                    badge.classList.remove('hidden');
                }
            }
        });
    }

    function scrollToBottom() {
        const container = document.getElementById('chat-messages');
        container.scrollTop = container.scrollHeight;
    }

    document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if(e.key === 'Enter') window.sendChatMessage();
    });

</script>
</body>
</html>